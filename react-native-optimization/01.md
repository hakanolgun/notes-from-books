# PART 1

## 01 - Pay attention to UI re-renders

**Issue**: Incorrect state updates cause extraneous rendering cycles

- By default, a component re-render if its parent is re-rendering or the props are different. This means that your component’s render method
  can sometimes run, even if their props didn’t change. This is an ac-
  ceptable tradeoff in most scenarios, as comparing the two objects
  (the previous and current props) would take longer.

**Note**: Performing premature optimizations may have a counter-positive effect. Try looking at performance issues as soon as you spot dropped frames or undesired performance within your app.

**Solution**: Profile with Flipper and find out what are the causes for re-render. Optimize the number of state updates and use memoized components when needed. Atomic state.

## 02 - Use dedicated components for certain layouts

**Issue**: You are unaware of the higher-order components that are provided with React Native. Like FlatList. Or FlashList for better.

## 03 - Think twice before you pick an external library

- Be more selective and use smaller specialized library

`import moment from 'moment';` 67KB

`import dayjs from 'dayjs';` 2KB

`import { map } from 'lodash';` instead `import map from 'lodash/map';`
